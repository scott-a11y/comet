'use client';

import type { BuildingFloorGeometry, BuildingVertex, BuildingWallSegment } from '@/lib/types/building-geometry';

/**
 * Export floor plan to DXF (AutoCAD format)
 */
export function exportToDXF(
    geometry: BuildingFloorGeometry,
    scaleFtPerUnit: number,
    buildingName: string
): string {
    const { vertices, segments } = geometry;

    // DXF header
    let dxf = `0
SECTION
2
HEADER
9
$ACADVER
1
AC1015
9
$INSUNITS
70
1
0
ENDSEC
0
SECTION
2
ENTITIES
`;

    // Add lines for each segment
    segments.forEach((seg) => {
        const v1 = vertices.find((v) => v.id === seg.a);
        const v2 = vertices.find((v) => v.id === seg.b);

        if (v1 && v2) {
            // Convert to real-world coordinates (feet)
            const x1 = v1.x * scaleFtPerUnit;
            const y1 = v1.y * scaleFtPerUnit;
            const x2 = v2.x * scaleFtPerUnit;
            const y2 = v2.y * scaleFtPerUnit;

            dxf += `0
LINE
8
WALLS
10
${x1.toFixed(4)}
20
${y1.toFixed(4)}
30
0.0
11
${x2.toFixed(4)}
21
${y2.toFixed(4)}
31
0.0
`;
        }
    });

    // DXF footer
    dxf += `0
ENDSEC
0
EOF
`;

    return dxf;
}

/**
 * Export floor plan to SVG
 */
export function exportToSVG(
    geometry: BuildingFloorGeometry,
    scaleFtPerUnit: number,
    buildingName: string
): string {
    const { vertices, segments } = geometry;

    // Calculate bounding box
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    vertices.forEach((v) => {
        minX = Math.min(minX, v.x);
        minY = Math.min(minY, v.y);
        maxX = Math.max(maxX, v.x);
        maxY = Math.max(maxY, v.y);
    });

    const width = (maxX - minX) * scaleFtPerUnit;
    const height = (maxY - minY) * scaleFtPerUnit;
    const padding = 10;

    let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${width + padding * 2}" height="${height + padding * 2}" viewBox="${minX * scaleFtPerUnit - padding} ${minY * scaleFtPerUnit - padding} ${width + padding * 2} ${height + padding * 2}">
  <title>${buildingName} - Floor Plan</title>
  <desc>Generated by Comet Wall Designer</desc>
  
  <!-- Grid -->
  <defs>
    <pattern id="grid" width="12" height="12" patternUnits="userSpaceOnUse">
      <path d="M 12 0 L 0 0 0 12" fill="none" stroke="#e0e0e0" stroke-width="0.5"/>
    </pattern>
  </defs>
  <rect x="${minX * scaleFtPerUnit - padding}" y="${minY * scaleFtPerUnit - padding}" width="${width + padding * 2}" height="${height + padding * 2}" fill="url(#grid)"/>
  
  <!-- Walls -->
  <g id="walls" stroke="#000" stroke-width="3" stroke-linecap="round">
`;

    // Add lines for each segment
    segments.forEach((seg) => {
        const v1 = vertices.find((v) => v.id === seg.a);
        const v2 = vertices.find((v) => v.id === seg.b);

        if (v1 && v2) {
            const x1 = v1.x * scaleFtPerUnit;
            const y1 = v1.y * scaleFtPerUnit;
            const x2 = v2.x * scaleFtPerUnit;
            const y2 = v2.y * scaleFtPerUnit;

            svg += `    <line x1="${x1.toFixed(2)}" y1="${y1.toFixed(2)}" x2="${x2.toFixed(2)}" y2="${y2.toFixed(2)}" />\n`;
        }
    });

    svg += `  </g>
  
  <!-- Vertices -->
  <g id="vertices" fill="#0066cc" stroke="#fff" stroke-width="1">
`;

    vertices.forEach((v) => {
        const x = v.x * scaleFtPerUnit;
        const y = v.y * scaleFtPerUnit;
        svg += `    <circle cx="${x.toFixed(2)}" cy="${y.toFixed(2)}" r="2" />\n`;
    });

    svg += `  </g>
</svg>`;

    return svg;
}

/**
 * Download a file with the given content
 */
export function downloadFile(content: string, filename: string, mimeType: string) {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}

/**
 * Export floor plan to PDF (using SVG as intermediate)
 */
export async function exportToPDF(
    geometry: BuildingFloorGeometry,
    scaleFtPerUnit: number,
    buildingName: string
) {
    // For now, we'll export as SVG and let the user convert to PDF
    // In a production app, you'd use a library like jsPDF or pdfmake
    const svg = exportToSVG(geometry, scaleFtPerUnit, buildingName);
    downloadFile(svg, `${buildingName.replace(/\s+/g, '_')}_floor_plan.svg`, 'image/svg+xml');

    alert('SVG exported! You can convert this to PDF using online tools or Adobe Illustrator.');
}

/**
 * Calculate floor plan statistics
 */
export function calculateStats(
    geometry: BuildingFloorGeometry,
    scaleFtPerUnit: number
): {
    totalWallLength: number;
    perimeter: number;
    estimatedArea: number;
    vertexCount: number;
    wallCount: number;
} {
    const { vertices, segments } = geometry;

    let totalWallLength = 0;
    segments.forEach((seg) => {
        const v1 = vertices.find((v) => v.id === seg.a);
        const v2 = vertices.find((v) => v.id === seg.b);

        if (v1 && v2) {
            const dx = (v2.x - v1.x) * scaleFtPerUnit;
            const dy = (v2.y - v1.y) * scaleFtPerUnit;
            const length = Math.sqrt(dx * dx + dy * dy);
            totalWallLength += length;
        }
    });

    // Simple area estimation using bounding box
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    vertices.forEach((v) => {
        minX = Math.min(minX, v.x);
        minY = Math.min(minY, v.y);
        maxX = Math.max(maxX, v.x);
        maxY = Math.max(maxY, v.y);
    });

    const width = (maxX - minX) * scaleFtPerUnit;
    const height = (maxY - minY) * scaleFtPerUnit;
    const estimatedArea = width * height;

    return {
        totalWallLength: Math.round(totalWallLength * 10) / 10,
        perimeter: Math.round(totalWallLength * 10) / 10,
        estimatedArea: Math.round(estimatedArea),
        vertexCount: vertices.length,
        wallCount: segments.length,
    };
}
